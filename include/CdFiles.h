#ifndef MYUC_CDFILES_H
#define MYUC_CDFILES_H

/*---------------------------------------
* Header file autogenerated by MyuCTemplatizer
* ---------------------------------------*/

#include "psx/LibCd.h"
#include "psx/LibGpu.h"
#include "psx/LibEtc.h"
#include "psx/LibPress.h"

#include "res.h"
#include "GlobalBuffer.h"
#include "Heap.h"
#include "Common.h"
#include "Audio.h"
#include "Movie.h"

#ifdef __cplusplus
extern "C" {
#endif

#define CDFILE_MODE_FLAG_XASTREAM 0x80
#define CDFILE_MODE_FLAG_AUDIO 0x40 //??? Used only for BGM and SE
#define CDFILE_MODE_FLAG_LZ77 0x20
#define CDFILE_MODE_FLAG_INDEX_OFFSET 0x10

#define CD_REQ_SLOT_COUNT 12
#define CD_REQ_MAX_SLOT (CD_REQ_SLOT_COUNT - 1)

	typedef enum ReqStatus {
		ReqStatus_Idle = 0, //0
		ReqStatus_Interrupt, //1,
		ReqStatus_Error, //2
		ReqStatus_PendingData = 6, //6
		ReqStatus_PendingDataDebug, //7
		ReqStatus_XAAudioDebug, //8
		ReqStatus_XAAudioActive, //9
		ReqStatus_XAAudioDone, //10
		ReqStatus_MoviePending, //11
		ReqStatus_MovieReady, //12
		ReqStatus_VabPendingDebug, //13
		ReqStatus_VabLoadingDebug, //14
		ReqStatus_VabPending, //15
		ReqStatus_VabLoading, //16
		ReqStatus_VabWaiting //17
	} ReqStatus;

	typedef enum CdLoadState {
		/*00*/	CdLoadState_Idle = 0,

	} CdLoadState;

	typedef struct CdFileLoadRequest {
		/*0x00*/ uint8_t mode; //0x800ffde0
		/*0x01*/ uint8_t status; //0x800ffde1
		/*0x02*/ union {
					uint16_t arcId;
					uint16_t movieId;
				 } id1; //0x800ffde2

		/*0x04*/ union {
					uint32_t fileOffset;
					uint32_t fileIndex;
					uint32_t sampleGroup;
				 } id2; //0x800ffde4

		//uint16_t arcId;
		//uint32_t fileOffset;

		/*0x08*/ int32_t sampleId; //0x800ffde8
		/*0x0c*/ int32_t len; //0x800ffdec //bytes remaining?
		/*0x10*/ uint8_t* dst; //0x800ffdf0
	} CdFileLoadRequest; //Size = 0x14

	typedef struct CdReqGeneralInfo {
		/*0x0000*/ uint16_t fileMedium; //0x800ffd08
		/*0x0002*/ uint16_t unk_ffd0a; //0x800ffd0a
		/*0x0004*/ uint16_t unk_ffd0c; //0x800ffd0c

		/*0x0006*/ uint16_t slotsUsed; //0x800ffd0e 
		/*0x0008*/ uint16_t nextSlot; //0x800ffd10

		/*0x000a*/ uint16_t slotIndex; //0x800ffd12

		/*0x000c*/ uint8_t unk_ffd14; //0x800ffd14

		/*0x000d*/ uint8_t loadState; //0x800ffd15 Some kind of overall status enum?
		/*0x000e*/ uint8_t unk_ffd16; //0x800ffd16
		/*0x000f*/ uint8_t unk_ffd17; //0x800ffd17
	} CdReqGeneralInfo; //Size = 0x10

	typedef struct CdReqDriveCtx {
		/*0x0000*/ uint8_t driveResponse[8]; //0x800ffd18 Looks like it stores responses to commands for the drive
		/*0x0008*/ uint32_t unk_ffd20; //0x800ffd20
		/*0x000c*/ uint8_t unk_ffd24[4]; //0x800ffd24
		/*0x0010*/ uint32_t loadOffset; //0x800ffd28 - USually has request.fileOffset (or file index) written to it?
		/*0x0014*/ uint32_t loadRemaining; //0x800ffd2c - Has request.unk_0c written to it
		/*0x0018*/ uint8_t* loadDest; //0x800ffd30 Has request.unk_10 written to it
		/*0x001c*/ uint8_t* comprDataBuffer; //0x800ffd34
		/*0x0020*/ uint8_t* comprFileBuffer; //0x800ffd38
		/*0x0024*/ uint8_t* decompDataEnd; //0x800ffd3c - Maybe end of buffer, actually?
		/*0x0028*/ CdlLOC unk_ffd40; //0x800ffd40 - Often used as control params.
		/*0x002c*/ CdlLOC unk_ffd44; //0x800ffd44
		/*0x0030*/ int32_t reqSector; //0x800ffd48
		/*0x0034*/ uint32_t unk_ffd4c; //0x800ffd4c
		/*0x0038*/ uint8_t unk_ffd50[4]; //0x800ffd50
		/*0x003c*/ uint32_t reqSectorOffset; //0x800ffd54
	} CdReqDriveCtx; //Size = 0x40

	typedef struct CdAudioCtx {
		/*0x0000*/ CdlATV unk_ffdc0; //0x800ffdc0 used in audio stuff?
		/*0x0004*/ uint8_t unk_ffdc4; //0x800ffdc4 used for CdControl params during streaming VOICE
		/*0x0005*/ uint8_t unk_ffdc5; //0x800ffdc5 current VOICE channel?
		/*0x0006*/ uint8_t unk_ffdc6[2]; //0x800ffdc6
		/*0x0008*/ CdlLOC unk_ffdc8; //0x800ffdc8 current VOICE clip start
		/*0x000c*/ CdlLOC unk_ffdcc; //0x800ffdcc current VOICE clip end
		/*0x0010*/ uint32_t unk_ffdd0; //0x800ffdd0
		/*0x0014*/ uint32_t unk_ffdd4; //0x800ffdd4
		/*0x0018*/ uint32_t unk_ffdd8; //0x800ffdd8

		/*0x001c*/ uint16_t unk_ffddc; //0x800ffddc
		/*0x001e*/ uint8_t unk_ffdde[2];
	} CdAudioCtx; //Size = 0x20

	typedef struct CdFilesContext {
		/*0x0000*/ CdReqGeneralInfo reqCommon; //0x800ffd08
		/*0x0010*/ CdReqDriveCtx driveState; //0x800ffd18
		/*0x0050*/ CdlLOC fileLocs[_GameFileCount]; //0x800ffd58
		/*0x0084*/ uint32_t fileSizes[_GameFileCount]; //0x800ffd8c
		/*0x00b8*/ CdAudioCtx audioCtx; //0x800ffdc0
	} CdFilesContext;

	typedef struct CdLoadContext {
		/*0x0000*/ CdFileLoadRequest loadRequests[CD_REQ_SLOT_COUNT]; //0x800ffde0
		/*0x00f0*/ uint8_t unk_ffed0[0x40]; //0x800ffed0
	} CdLoadContext;

	BOOL CdFiles_ClearLoadRequests(void);
	void CdFiles_8003C2BC(void);
	BOOL CdFiles_RequestCdFile(uint8_t mode, uint16_t fileId, uint32_t offset, int32_t subId, int32_t size, void* dest);
	void CdFiles_8003C664(void);
	void CdFiles_8003C790(void);
	s32 CdFiles_8003FDF8(void);
	s32 CdFiles_8003FE5C(void);
	BOOL CdFiles_8003FEA0(uint16_t arg0);
	BOOL CdFiles_AllSlotsEmpty(void);
	void CdFiles_RequestVoiceClip(uint32_t group, int32_t id);
	int32_t CdFiles_RequestMovie(uint16_t fileId);

	//	.data 0x800e1f68
	extern uint32_t* gFilePos[];

	//	.bss 0x800ffd08
	extern CdFilesContext gCdFilesCtx;

	//	.bss 0x800ffde0
	extern CdLoadContext gCdLoadCtx;

#ifdef __cplusplus
}
#endif

#endif
