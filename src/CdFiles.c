/*---------------------------------------
* .c file template autogenerated by MyuCTemplatizer
* ---------------------------------------*/

#include "asm/include_asm.h"

#include "CdFiles.h"
#include "psx/LibSn.h"

#ifdef __cplusplus
extern "C" {
#endif

/*----- Declarations -----*/

void _cdfiles_8003C8E4(uint8_t arg0, uint8_t* arg1); //Seems to be default cd ready callback
void _cdfiles_8003D208(void);
void _cdFiles_MdecOutCallback();
void* _cdFiles_DecompressLZ77(void* dst, void* src);
BOOL _cdfiles_UNUSED_8003FED4(uint16_t arg0);
void _cdFiles_PCLoadFileData(char* filename, int len, u32 offset, void* dst);
int32_t _cdFiles_PCWriteFileData(char* fileName, int32_t len, char* src);
void _cdfiles_UNUSED_800401AC(void);
void _cdFiles_GetPrefixedGamefileName(uint16_t fileIndex, char* dst);
void _cdFiles_GetSuffixedGamefileName(uint16_t fileIndex, char* dst);
void _cdfiles_80040348(void);
void _cdfiles_80040430(void);
int32_t _cdfiles_800404B0(char* filename);
uint32_t* _cdfiles_UNUSED_8004051C(void);

/*----- ROData -----*/

//INCLUDE_RODATA("asm/data", "CdFiles.rodata");

/*----- SData -----*/

//   .sdata 0x800fe888
static char sCdFilesEmptyString[] = "\0\0\0";

//   .sdata 0x800fe88c
static char sCdFilePrefix[] = "i:\\cd";

static uint16_t ssdataPadding = 0;

/*----- Data -----*/

//   .data 0x800e1f68
uint32_t* gFilePos[] = {
	EMPTY_PTR, gFilePosUnit, gFilePosScreen, gFilePosSystem, gFilePosSce, gFilePosAnime, 
	gFilePosEffect, gFilePosFace, gFilePosField, EMPTY_PTR, gFilePosBgm, gFilePosSe, 
	EMPTY_PTR};

//   .data 0x800e1f9c
static uint32_t* sFileMemsize[] = {
	EMPTY_PTR, gFileSizeUnit, gFileSizeScreen, gFileSizeSystem, EMPTY_PTR, EMPTY_PTR, 
	gFileSizeEffect, gFileSizeFace, gFileSizeField, EMPTY_PTR, EMPTY_PTR, EMPTY_PTR, 
	EMPTY_PTR};

//   .data 0x800e1fd0
static const char* sFileNames[] = {CD_FILE_NAMES};

//This is forced padding. Remove when jump tables are added.
__asm__(".section .rodata\n.word 0\n.section .text\n");

/*----- Uninitialized Data -----*/

static MovieContext* gpMovieContext;
static UnkStr_fea80* D_cdfile_sbss_fea80; //Size: 0x46000 (wow)
static void* D_cdfile_sbss_fea84; //Size: 0x10000
static DECDCTTAB* gpMovieDecTbl; //Size: 0x11000
static uint32_t sPaddingSBSS;

//	.bss 0x800ffd08
CdFilesContext gCdFilesCtx;

//	.bss 0x800ffde0
CdLoadContext gCdLoadCtx;

/*----- Inline Functions -----*/

/*----- .text Functions -----*/

//   .text 0x8003c1cc
BOOL CdFiles_ClearLoadRequests(void) {
	int32_t i;

	CdDrive_CdInit();
	CdDrive_CdSetDebug(0);

	gCdFilesCtx.reqCommon.fileMedium = 3;
	gCdFilesCtx.reqCommon.unk_ffd14 = 0;
	gCdFilesCtx.reqCommon.unk_ffd0c = 0;
	gCdFilesCtx.driveState.driveResponse[0] = 0;
	gCdFilesCtx.reqCommon.unk_ffd16 = 0;

	for (i = 0; i < 13; i++) {
		gCdFilesCtx.fileLocs[i].minute = 0;
		gCdFilesCtx.fileLocs[i].second = 0;
		gCdFilesCtx.fileLocs[i].sector = 0;
		gCdFilesCtx.fileLocs[i].track = 0;
		gCdFilesCtx.fileSizes[i] = 0;
	}

	gCdFilesCtx.reqCommon.slotsUsed = 0;
	gCdFilesCtx.reqCommon.nextSlot = 0;
	gCdFilesCtx.reqCommon.slotIndex = 0;
	gCdFilesCtx.audioCtx.unk_ffddc = 0;

	for (i = 0; i < 12; i++) {
		gCdLoadCtx.loadRequests[i].mode = 0;
		gCdLoadCtx.loadRequests[i].status = 0;
		gCdLoadCtx.loadRequests[i].id1.arcId = ~0;
		gCdLoadCtx.loadRequests[i].id2.fileOffset = 0;
		gCdLoadCtx.loadRequests[i].sampleId = 0;
		gCdLoadCtx.loadRequests[i].len = 0;
		gCdLoadCtx.loadRequests[i].dst = EMPTY_PTR;
	}

	gCdFilesCtx.reqCommon.unk_ffd0a = 0;
	gCdFilesCtx.reqCommon.loadState = CdLoadState_Idle;
	CdDrive_CdReadyCallback(_cdfiles_8003C8E4);
	gApplState.stateFlags[0] |= 0x400;

	return TRUE;
}

//   .text 0x8003c2bc
void __nojrra_8003c2bc(void) {
	INCLUDE_ASM("asm/split/CdFiles", "CdFiles_8003C2BC");
}

//   .text 0x8003c544
BOOL CdFiles_RequestCdFile(uint8_t mode, uint16_t fileId, uint32_t offset, int32_t subId, int32_t size, void* dest) {
	if (gCdFilesCtx.reqCommon.slotsUsed >= CD_REQ_SLOT_COUNT) {
		return FALSE;
	}

	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].mode = mode;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].status = 0;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].id1.arcId = fileId;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].id2.fileOffset = offset;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].sampleId = subId;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].len = size;
	gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.nextSlot].dst = (uint8_t*)dest;

	if (gCdFilesCtx.reqCommon.nextSlot < CD_REQ_MAX_SLOT) {
		gCdFilesCtx.reqCommon.nextSlot++;
	}
	else {
		gCdFilesCtx.reqCommon.nextSlot = 0;
	}

	gCdFilesCtx.audioCtx.unk_ffddc++;
	gCdFilesCtx.reqCommon.slotsUsed++;
	return TRUE;
}

//   .text 0x8003c664
void __nojrra_8003c664(void) {
	INCLUDE_ASM("asm/split/CdFiles", "CdFiles_8003C664");
}

//   .text 0x8003c790
void __nojrra_8003c790(void) {
	INCLUDE_ASM("asm/split/CdFiles", "CdFiles_8003C790");
}

//   .text 0x8003c8e4
void __nojrra_8003c8e4(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdfiles_8003C8E4");
}

//   .text 0x8003d208
//This function is a MONSTER
void __nojrra_8003d208(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdfiles_8003D208");
}

//   .text 0x8003f9f0
void __nojrra_8003f9f0(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdFiles_MdecOutCallback");
}

//   .text 0x8003fb0c
void __nojrra_8003fb0c(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdFiles_DecompressLZ77");
}

//   .text 0x8003fdf8
s32 CdFiles_8003FDF8(void) {
	gCdFilesCtx.reqCommon.unk_ffd14 = 0;
	gCdFilesCtx.reqCommon.unk_ffd0c = 0;
	gCdFilesCtx.driveState.driveResponse[0] = 0;
	gCdFilesCtx.reqCommon.unk_ffd16 = 0;
	gCdFilesCtx.reqCommon.slotsUsed = 0;
	gCdFilesCtx.reqCommon.nextSlot = 0;
	gCdFilesCtx.reqCommon.slotIndex = 0;
	gCdFilesCtx.audioCtx.unk_ffddc = 0;
	gCdFilesCtx.reqCommon.unk_ffd0a = 0;
	gCdFilesCtx.reqCommon.loadState = CdLoadState_Idle;
	CdDrive_CdReadyCallback(_cdfiles_8003C8E4);
	gApplState.stateFlags[0] |= 0x400;
	return 1;
}

//   .text 0x8003fe5c
s32 CdFiles_8003FE5C(void) {
	gCdFilesCtx.reqCommon.loadState = CdLoadState_Idle;
	gApplState.stateFlags[0] &= ~0x400;
	CdDrive_CdReadCallback(NULL);
	CdDrive_CdReadyCallback(NULL);
	return 1;
}

//   .text 0x8003fea0
BOOL CdFiles_8003FEA0(uint16_t arg0) {
	return gCdFilesCtx.reqCommon.slotsUsed < ((gCdFilesCtx.audioCtx.unk_ffddc - arg0) & 0xFF);
}

//   .text 0x8003fec4
BOOL CdFiles_AllSlotsEmpty(void) {
	return gCdFilesCtx.reqCommon.slotsUsed == 0;
}

//   .text 0x8003fed4
BOOL _cdfiles_UNUSED_8003FED4(uint16_t arg0) {
	return arg0 < (CD_REQ_SLOT_COUNT - gCdFilesCtx.reqCommon.slotsUsed);
}

//   .text 0x8003fef0
void CdFiles_RequestVoiceClip(uint32_t group, int32_t id) {
	CdFiles_RequestCdFile(CDFILE_MODE_FLAG_XASTREAM, NoFile, group, id, 0, NULL);
}

//   .text 0x8003ff24
void __nojrra_8003ff24(void) {
	INCLUDE_ASM("asm/split/CdFiles", "CdFiles_RequestMovie");
}

void __nojrra_80040010(void) {
	//   .text 0x80040010
	INCLUDE_ASM("asm/split/CdFiles", "_cdFiles_PCLoadFileData");
}

//   .text 0x80040108
int32_t _cdFiles_PCWriteFileData(char* fileName, int32_t len, char* src) {
	int32_t fileHandle;
	int32_t amt;

	fileHandle = Sn_PCcreat(fileName, 0U);
	if (fileHandle != -1) {
		while (len != 0) {
			if (len >= 0x800) {
				amt = Sn_PCwrite(fileHandle, src, 0x800);
				if (amt == 0) break;
				len -= amt;
				src += amt;
			}
			else {
				amt = Sn_PCwrite(fileHandle, src, len);
				if (amt == 0) break;
				len -= amt;
				src += amt;
			}
		}
		Sn_PCclose(fileHandle);
		return 0;
	}
	return -1;
}

//   .text 0x800401ac
void _cdfiles_UNUSED_800401AC(void) {
	//Might be inlined
	if (gCdFilesCtx.reqCommon.slotsUsed != 0) {
		gCdLoadCtx.loadRequests[gCdFilesCtx.reqCommon.slotIndex].status = 0;
		if (gCdFilesCtx.reqCommon.slotIndex < CD_REQ_MAX_SLOT) {
			gCdFilesCtx.reqCommon.slotIndex++;
		}
		else {
			gCdFilesCtx.reqCommon.slotIndex = 0;
		}
		gCdFilesCtx.reqCommon.slotsUsed--;
	}
}

//   .text 0x8004021c
void __nojrra_8004021C(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdFiles_GetPrefixedGamefileName");
}

//   .text 0x800402c4
void _cdFiles_GetSuffixedGamefileName(uint16_t fileIndex, char* dst) {
	//Might be inlined
	int i = 0;

	for (i = 0; sFileNames[fileIndex][i] != '\0'; i++) {
		*dst++ = sFileNames[fileIndex][i];
	}

	*dst++ = ';';
	*dst++ = '1';
	*dst = '\0';
}

void __nojrra_80040348(void) {
	//   .text 0x80040348
	INCLUDE_ASM("asm/split/CdFiles", "_cdfiles_80040348");
}

//   .text 0x80040430
void _cdfiles_80040430(MovieContext* ctx) {
	volatile int ctr = 2000;
	int temp;

	if (ctx->unk1C) {
		ctx->unk1C = 0;
		return;
	}

	while (!ctx->unk1C) {
		if (--ctr == 0) {
			ctx->unk1C = 1;
			ctx->unk2C ^= 1;
			ctx->unk44.x = ctx->unk0.x;
			temp = ctx->unk0.y;
			if (ctx->unk2C != 0) {
				temp += 0xF0;
			}
			ctx->unk44.y = temp;
		}
	}
	ctx->unk1C = 0;
}

//   .text 0x800404b0
int32_t _cdfiles_800404B0(char* fileName) {
	int32_t handleId;
	int32_t seekPos;

	handleId = Sn_PCopen(fileName, 0, 0);
	if (handleId != -1) {
		seekPos = Sn_PClseek(handleId, 0, 2);
		Sn_PClseek(handleId, 0, 0);
		Sn_PCclose(handleId);
		return seekPos;
	}
	else return -1;
}

//   .text 0x8004051c
void __nojrra_8004051C(void) {
	INCLUDE_ASM("asm/split/CdFiles", "_cdfiles_UNUSED_8004051C");
}

#ifdef __cplusplus
}
#endif

